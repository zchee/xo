package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
)

// EnumValue is a enum value.
type EnumValue struct {
	EnumValue  string `json:"enum_value"`  // enum_value
	ConstValue int    `json:"const_value"` // const_value
}

// PostgresEnumValues runs a custom query, returning results as EnumValue.
func PostgresEnumValues(ctx context.Context, db DB, schema, table, enum string) ([]*EnumValue, error) {
	// query
	const sqlstr = `SELECT ` +
		`e.enumlabel, ` + // ::varchar AS enum_value
		`e.enumsortorder ` + // ::integer AS const_value
		`FROM pg_class c ` +
		`JOIN pg_attribute a ON c.oid = a.attrelid ` +
		`JOIN pg_type t on a.atttypid = t.oid ` +
		`JOIN ONLY pg_namespace n ON n.oid = t.typnamespace ` +
		`LEFT JOIN pg_enum e ON t.oid = e.enumtypid ` +
		`WHERE n.nspname = $1 ` +
		`AND c.relname::varchar = $2 ` +
		`AND t.typname = $3`
	// run
	logf(sqlstr, schema, table, enum)
	rows, err := db.QueryContext(ctx, sqlstr, schema, table, enum)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*EnumValue
	for rows.Next() {
		var ev EnumValue
		// scan
		if err := rows.Scan(&ev.EnumValue, &ev.ConstValue); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &ev)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
